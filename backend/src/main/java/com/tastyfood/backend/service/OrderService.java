package com.tastyfood.backend.service;

import com.tastyfood.backend.dbinterface.DBInterfaceOrders;
import com.tastyfood.backend.dbinterface.DBInterfaceOrderItems;
import com.tastyfood.backend.domain.DeliveryAddress;
import com.tastyfood.backend.domain.Order;
import com.tastyfood.backend.domain.OrderItem;
import com.tastyfood.backend.enums.OrderStatus;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;
import java.util.Optional;

@Service
public class OrderService {
    
    @Autowired
    private DBInterfaceOrders orderDbInterface;
    
    @Autowired
    private DBInterfaceOrderItems orderItemDbInterface;
    
    @Autowired
    private MenuService menuService;
    
    @Autowired
    private DeliveryAddressService deliveryAddressService;
    
    /**
     * Generates an order number in the format FD#### based on orderId
     * Uses a deterministic but seemingly random approach to convert orderId to 4 digits
     * @param orderId The order ID to convert
     * @return An order number string in format FD####
     */
    private String generateOrderNumberFromId(Integer orderId) {
        // Use orderId to generate a 4-digit number (0-9999)
        // We'll use a combination of orderId and a simple hash to make it look more random
        // This ensures uniqueness while appearing random
        int hash = (orderId * 7919 + 12345) % 10000; // Prime number multiplication for better distribution
        if (hash < 0) hash = -hash; // Ensure positive
        return String.format("FD%04d", hash);
    }
    
    public List<Order> getAllOrders() {
        List<Order> orders = orderDbInterface.findAllByOrderByCreatedAtDesc();
        // Generate order numbers for all orders
        orders.forEach(order -> {
            if (order.getOrderNumber() == null && order.getOrderId() != null) {
                order.setOrderNumber(generateOrderNumberFromId(order.getOrderId()));
            }
        });
        return orders;
    }
    
    public Optional<Order> getOrderById(Integer orderId) {
        Optional<Order> orderOpt = orderDbInterface.findById(orderId);
        // Generate order number if it doesn't exist
        orderOpt.ifPresent(order -> {
            if (order.getOrderNumber() == null && order.getOrderId() != null) {
                order.setOrderNumber(generateOrderNumberFromId(order.getOrderId()));
            }
        });
        return orderOpt;
    }
    
    public List<Order> getOrdersByStatus(OrderStatus status) {
        List<Order> orders = orderDbInterface.findByStatus(status);
        // Generate order numbers for all orders
        orders.forEach(order -> {
            if (order.getOrderNumber() == null && order.getOrderId() != null) {
                order.setOrderNumber(generateOrderNumberFromId(order.getOrderId()));
            }
        });
        return orders;
    }
    
    public List<Order> getOrdersByDriver(Integer driverId) {
        List<Order> orders = orderDbInterface.findByDriverId(driverId);
        // Generate order numbers for all orders
        orders.forEach(order -> {
            if (order.getOrderNumber() == null && order.getOrderId() != null) {
                order.setOrderNumber(generateOrderNumberFromId(order.getOrderId()));
            }
        });
        return orders;
    }
    
    @Transactional
    public Order createOrder(Order order, List<OrderItem> orderItems, DeliveryAddress deliveryAddress) {
        order.setCreatedAt(Instant.now());
        order.setLastUpdatedAt(Instant.now());
        if (order.getStatus() == null) {
            order.setStatus(OrderStatus.PENDING);
        }
        
        // Find or create delivery address
        if (deliveryAddress != null) {
            DeliveryAddress savedAddress = deliveryAddressService.findOrCreateAddress(deliveryAddress);
            order.setDeliveryAddress(savedAddress);
            order.setAddressId(savedAddress.getAddressId());
        }
        
        // Calculate totals
        BigDecimal subtotal = orderItems.stream()
            .map(item -> item.getLineTotal())
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        order.setSubtotal(subtotal);
        BigDecimal tip = order.getTip() != null ? order.getTip() : BigDecimal.ZERO;
        order.setGrandTotal(subtotal.add(tip));
        
        Order savedOrder = orderDbInterface.save(order);
        
        // Generate order number based on the saved orderId (after it's been generated by the database)
        savedOrder.setOrderNumber(generateOrderNumberFromId(savedOrder.getOrderId()));
        
        // Save order items
        for (OrderItem item : orderItems) {
            item.setOrderId(savedOrder.getOrderId());
            orderItemDbInterface.save(item);
        }
        
        return savedOrder;
    }
    
    @Transactional
    public Order updateOrder(Order order) {
        order.setLastUpdatedAt(Instant.now());
        return orderDbInterface.save(order);
    }
    
    public List<OrderItem> getOrderItems(Integer orderId) {
        return orderItemDbInterface.findByOrderId(orderId);
    }
    
    @Transactional
    public boolean deleteOrder(Integer orderId) {
        if (!orderDbInterface.existsById(orderId)) {
            return false;
        }
        // Delete order items first
        List<OrderItem> items = orderItemDbInterface.findByOrderId(orderId);
        for (OrderItem item : items) {
            orderItemDbInterface.delete(item);
        }
        orderDbInterface.deleteById(orderId);
        return true;
    }
}
